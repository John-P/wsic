import shutil
import tempfile
import uuid
from abc import ABC, abstractmethod
from functools import partial
from math import ceil
from pathlib import Path
from typing import Callable, Iterable, Iterator, Optional, Tuple, Union

import numpy as np
import zarr

from wsic.codecs import register_codecs
from wsic.readers import MultiProcessTileIterator, Reader
from wsic.types import PathLike


class Writer(ABC):
    """Base class for image writers.

    Args:
        path (PathLike):
            Path to the output file.
        shape (Tuple[int, int]):
            Shape of the output image.
        tile_size (Tuple[int, int], optional):
            A (width, height) tuple of output tile size in pixels.
            Defaults to (256, 256).
        overwrite (bool, optional):
            Overwrite output file if it exists.
            Defaults to False.
        verbose (bool, optional):
            Print more output. Defaults to False.
    """

    def __init__(
        self,
        path: PathLike,
        shape: Tuple[int, int],
        tile_size: Tuple[int, int] = (256, 256),
        overwrite: bool = False,
        verbose: bool = False,
    ):
        self.path = Path(path)
        self.shape = shape
        self.overwrite = overwrite
        self.tile_size = tile_size
        self.overwrite = overwrite
        self.verbose = verbose

        if self.path.exists() and not self.overwrite:
            raise FileExistsError(f"{self.path} already exists")

    def reader_tile_iterator(
        self,
        reader: Reader,
        num_workers: int = 2,
        read_tile_size: Tuple[int, int] = None,
        yield_tile_size: Tuple[int, int] = None,
        intermediate: zarr.Group = None,
    ) -> Iterator:
        """Returns an iterator which returns tiles generated by reader.

        Args:
            reader (Reader):
                Reader to read tiles from.
            num_workers (int, optional):
                Number of workers to use. Defaults to 2.
            read_tile_size (Tuple[int, int], optional):
                A (width, height) tuple of read tile size in pixels.
                Defaults to self.tile_size.
            intermediate (np.ndarray, optional):
                An intermediate image to write tiles to.

        Returns:
            Iterator: Iterator which returns tiles generated by reader.

        """

        if read_tile_size is None:
            read_tile_size = self.tile_size
        return MultiProcessTileIterator(
            reader=reader,
            read_tile_size=read_tile_size,
            yield_tile_size=yield_tile_size or self.tile_size,
            intermediate=intermediate,
            num_workers=num_workers,
            verbose=self.verbose,
        )

    def __setitem__(
        self, index: Tuple[Union[int, slice], ...], value: np.ndarray
    ) -> None:
        """Return pixel data at index."""
        raise NotImplementedError()

    @abstractmethod
    def copy_from_reader(
        self, data: bytes, verbose: bool = False, num_workers: int = 2
    ) -> None:
        """Write data to output file by copying from a Reader.

        Args:
            reader (Reader):
                Reader object.
            verbose (bool, optional):
                Print progress. Defaults to False.
            num_workers (int, optional):
                Number of workers to use. Defaults to 2.
            read_tile_size (Tuple[int, int], optional):
                Tile size to read. Defaults to None.
                This will use the tile size of the writer if None.
        """
        if self.path.exists() and not self.overwrite:
            raise FileExistsError(f"{self.path} exists and overwrite is False.")

    @staticmethod
    def progress_bar(iterable: Iterable, **kwargs) -> Iterator:
        """Wrap a tile reader iterable in a progress bar.

        Used to display progress when copying from a reader.

        Some of the tqdm defaults are overridden but can be changed by
        passing values as kwargs. Parameters which differ to the tqdm
        defaults here are:
        - `smoothing = 0`
        - `colour = "magenta"`

        Args:
            iterable (Iterable):
                The iterable to wrap.
            **kwargs (dict):
                Extra kwargs for tqdm. Overrides defaults.
        """
        tqdm_kwargs = {
            "colour": "magenta",
            "smoothing": 0,
        }
        tqdm_kwargs.update(kwargs)
        try:
            from tqdm.auto import tqdm

            return tqdm(iterable, **tqdm_kwargs)
        except ImportError:
            return iterable


class JP2Writer(Writer):
    """Tile-wise JP2 writer using glymur.

    Note that when writing tiled JP2 files, the tiles must all be the
    same size and must be written in the order left-to-right, then
    top-to-bottom (row-by-row). Tiles cannot be skipped.
    """

    def __init__(
        self,
        path: Path,
        shape: Tuple[int, int],
        tile_size: Tuple[int, int] = (256, 256),
        overwrite: bool = False,
        verbose: bool = False,
    ) -> None:
        super().__init__(
            path=path,
            shape=shape,
            tile_size=tile_size,
            overwrite=overwrite,
            verbose=verbose,
        )
        self.image = None

    def __setitem__(self, index: Tuple[int, ...], value: np.ndarray) -> None:
        """Write pixel data at index. Not supported for JP2Writer."""
        raise NotImplementedError("JP2 files do not support random access writes.")

    def copy_from_reader(
        self,
        reader: Reader,
        num_workers: int = 2,
        read_tile_size: Optional[Tuple[int, int]] = None,
        verbose: bool = False,
    ) -> None:
        """Copy pixel data from a reader."""
        import glymur

        jp2 = glymur.Jp2k(
            self.path, shape=reader.shape, tilesize=self.tile_size, verbose=verbose
        )
        reader_tile_iterator = self.reader_tile_iterator(
            reader=reader,
            num_workers=num_workers,
            read_tile_size=read_tile_size or self.tile_size,
        )
        reader_tile_iterator = self.progress_bar(reader_tile_iterator)
        for tile_writer in jp2.get_tilewriters():
            tile_writer[:] = next(reader_tile_iterator)


class TiledTIFFWriter(Writer):
    """Tile-wise TIFF writer using tifffile.

    Note that when writing tiled TIFF files, the tiles must all be the
    same size and must be written in the order left-to-right, then
    top-to-bottom (row-by-row). Tiles cannot be skipped.
    """

    def __init__(
        self,
        path: Path,
        shape: Tuple[int, int],
        tile_size: Tuple[int, int] = (256, 256),
        overwrite: bool = False,
        verbose: bool = False,
        photometric: str = "rgb",
        compression: str = "jpeg",
        compression_level: int = 95,
        microns_per_pixel: float = None,  # Currently unused
    ) -> None:
        super().__init__(
            path=path,
            shape=shape,
            tile_size=tile_size,
            overwrite=overwrite,
            verbose=verbose,
        )
        self.image = None
        self.photometric = photometric
        self.compression = compression
        self.compression_level = compression_level
        self.microns_per_pixel = microns_per_pixel

    def __setitem__(self, index: Tuple[int, ...], value: np.ndarray) -> None:
        """Write pixel data at index. Not supported for TIFFWriter.

        In theory this is possible but it can be complex. If the new tile
        is larger in bytes, the tile will have to be added to the end of the
        file. The old tile will remain in the file and waste space unless it
        is later overwritten by another of length smaller or equal to the
        original tile.
        """
        raise NotImplementedError(
            "Compressed tiled TIFF files do not support random access writes."
        )

    def copy_from_reader(
        self,
        reader: Reader,
        num_workers: int = 2,
        read_tile_size: Optional[Tuple[int, int]] = None,
        verbose: bool = False,
    ) -> None:
        """Copy pixel data from a reader."""
        import tifffile

        with ZarrIntermediate(None, reader.shape, zero_after_read=True) as intermediate:
            reader_tile_iterator = self.reader_tile_iterator(
                reader=reader,
                num_workers=num_workers,
                intermediate=intermediate,
                read_tile_size=read_tile_size or self.tile_size,
            )
            reader_tile_iterator = self.progress_bar(reader_tile_iterator)
            tifffile.imwrite(
                self.path,
                reader_tile_iterator,
                tile=self.tile_size,
                shape=reader.shape,
                dtype=reader.dtype,
                photometric=self.photometric,
                compression=self.compression,
                bigtiff=True,
            )


class ZarrReaderWriter(Reader, Writer):
    """Zarr reader and writer."""

    def __init__(
        self,
        path: Path,
        shape: Optional[Tuple[int, int]] = None,
        dtype: Optional[str] = "u1",
        tile_size: Tuple[int, int] = (512, 512),
        overwrite: bool = False,
        verbose: bool = False,
        compression: str = "blosc-zstd",
        compression_level: int = 9,
    ) -> None:
        self.path = Path(path)
        self.tile_size = tile_size
        self.overwrite = overwrite
        self.compression = compression
        self.compression_level = compression_level
        register_codecs()
        self.compressor = self.get_codec(compression, compression_level)
        self.verbose = verbose
        if self.path.exists() and not self.path.is_dir():
            raise FileExistsError(
                f"{self.path} exists but is not a directory. Zarrs must be directories."
            )

        if self.path.exists() and self.path.is_dir():
            self.image = zarr.open(
                self.path,
                mode="r+",
            )
            self.shape = self.image.shape
            self.dtype = self.image.dtype
        else:
            self.dtype = dtype
            self.shape = shape
            self.image = zarr.open(
                zarr.NestedDirectoryStore(self.path),
                mode="a",
                shape=self.shape,
                chunks=self.tile_size,
                dtype=self.dtype,
                compressor=self.compressor,
            )

    def get_codec(
        self,
        compression: str,
        compression_level: int,
    ) -> Callable[[bytes], bytes]:
        """Get a codec for the given compression method and compression level."""
        from numcodecs import LZ4, LZMA, Blosc, Zlib, Zstd

        numcodecs_codecs = {
            "lz4": LZ4,
            "lzma": LZMA,
            "blosc": Blosc,
            "blosc-zstd": partial(Blosc, cname="zstd", shuffle=Blosc.BITSHUFFLE),
            "zlib": Zlib,
            "zstd": Zstd,
        }

        try:
            import imagecodecs

            imagecodecs_codecs = {
                "deflate": imagecodecs.numcodecs.Deflate,
                "webp": imagecodecs.numcodecs.Webp,
                "jpeg": imagecodecs.numcodecs.Jpeg,
                "jpegls": imagecodecs.numcodecs.Jpegls,
                "jpeg2000": imagecodecs.numcodecs.Jpeg2k,
                "jpegxl": imagecodecs.numcodecs.Jpegxl,
                "png": imagecodecs.numcodecs.Png,
                "zfp": imagecodecs.numcodecs.Zfp,
            }
        except ImportError:
            if self.verbose:
                print("imagecodecs not installed")
            imagecodecs_codecs = {}

        if compression in numcodecs_codecs:
            return numcodecs_codecs[compression](clevel=compression_level)

        if compression in imagecodecs_codecs:
            return imagecodecs_codecs[compression](level=compression_level)

        if compression == "qoi":
            from wsic.codecs import QOI

            return QOI()

        raise ValueError(f"Compression {compression} not supported.")

    def __setitem__(self, index: Tuple[int, ...], value: np.ndarray) -> None:
        """Write pixel data at index."""
        self.image[index] = value

    def __getitem__(self, index: Tuple[int, ...]) -> np.ndarray:
        """Read pixel data at index."""
        return self.image[index]

    def copy_from_reader(
        self,
        reader: Reader,
        verbose: bool = False,
        num_workers: int = 2,
        read_tile_size: Optional[Tuple[int, int]] = None,
    ) -> None:
        """Copy pixel data from a reader."""
        # Validate and normalise inputs
        lossy_codecs = ["jpeg"]
        optionally_lossy_codecs = ["jpeg2000", "webp", "jpegls", "jpegxl", "jpegxr"]
        lossy = self.compression in lossy_codecs or (
            self.compression in optionally_lossy_codecs and self.compression_level > 0
        )
        read_tile_size = read_tile_size or self.tile_size
        write_multiple_of_read = all(np.mod(read_tile_size, self.tile_size) == 0)
        if lossy and not write_multiple_of_read:
            raise ValueError(
                "Lossy compression requires that the tile write size is a "
                "multiple of the read tile size."
            )
        # Create a reader tile iterator
        reader_tile_iterator = self.reader_tile_iterator(
            reader,
            read_tile_size=read_tile_size,
            yield_tile_size=read_tile_size,
            num_workers=num_workers,
        )
        reader_tile_iterator = self.progress_bar(reader_tile_iterator)
        # Write the reader tile iterator to the writer
        tiles_shape = (
            ceil(reader.shape[0] / read_tile_size[0]),
            ceil(reader.shape[1] / read_tile_size[1]),
        )
        tiles_index = np.ndindex(tiles_shape)
        for (j, i), tile in zip(tiles_index, reader_tile_iterator):
            self.image[
                j * read_tile_size[1] : (j * read_tile_size[1]) + tile.shape[0],
                i * read_tile_size[0] : (i * read_tile_size[0]) + tile.shape[1],
            ] = tile


class ZarrIntermediate(Reader, Writer):
    """Zarr intermediate reader/writer.

    A convenience reader/writer which is also a context manager. This
    allows for changing of tile order or size when converting between
    formats and also avoids decoding the same tile from the original
    file twice. This is particularly useful for formats which are very
    computationally costly to decode such as JPEG 2000.

    Args:
        path (PathLike):
            Path to the output file. If None, a temporary file will be created.
        shape (Tuple[int, int]):
            Shape of the output file.
        tile_size (Tuple[int, int], optional):
            A (width, height) tuple of output tile size in pixels.
            Defaults to (256, 256).
        dtype (np.dtype):
            Data type of the output file.
        zero_after_read (bool, optional):
            If True, data in file will be zeroed after reading.
            Defaults to False.
        overwrite (bool, optional):
            If True, the output file will be overwritten if it exists.
            Defaults to False.
        verbose (bool, optional):
            If True, print information about the file being written.
    """

    def __init__(
        self,
        path: PathLike,
        shape: Tuple[int, int],
        tile_size: Tuple[int, int] = (256, 256),
        dtype="u1",
        zero_after_read: bool = False,
        overwrite: bool = False,
        verbose: bool = False,
    ) -> None:
        # Create a temporary path if no path is given
        path = path or Path(tempfile.gettempdir(), uuid.uuid4().hex).with_suffix(
            ".zarr"
        )
        super().__init__(path=path)
        self.shape = shape
        self.dtype = dtype
        self.tile_size = tile_size
        self.path.mkdir(parents=True, exist_ok=True)
        self.zarr = zarr.open(
            store=zarr.NestedDirectoryStore(path),
            mode="a",
            shape=self.shape,
            chunks=self.tile_size,
            dtype=self.dtype,
        )
        self.zero_after_read = zero_after_read
        self.overwrite = overwrite
        self.verbose = verbose

    def __setitem__(
        self, index: Tuple[Union[int, slice], ...], value: np.ndarray
    ) -> None:
        """Write pixel data at index."""
        self.zarr[index] = value

    def __getitem__(self, index: Tuple[int, ...]) -> np.ndarray:
        """Read pixel data at index."""
        result = self.zarr[index]
        if self.zero_after_read:
            self.zarr[index] = 0
        return result  # noqa: R504

    def __enter__(self) -> "ZarrIntermediate":
        """Enter the context manager."""
        return self

    def __exit__(self, exc_type, exc_value, traceback) -> None:
        """Exit the context manager."""
        shutil.rmtree(self.path)

    def copy_from_reader(
        self,
        reader: Reader,
        verbose: bool = False,
        num_workers: int = 2,
        read_tile_size: Optional[Tuple[int, int]] = None,
    ) -> None:
        """Copy pixel data from a reader."""
        raise NotImplementedError()
