import multiprocessing
import os
import time
import warnings
from abc import ABC
from math import ceil, floor
from pathlib import Path
from typing import Iterator, Optional, Tuple, Union

import numpy as np
import zarr

from wsic.magic import summon_file_types
from wsic.types import PathLike
from wsic.utils import (
    mosaic_shape,
    normalise_color_space,
    normalise_compression,
    ppu2mpp,
    tile_slices,
    wrap_index,
)


class Reader(ABC):
    """Base class for readers."""

    def __init__(self, path: PathLike):
        """Initialize reader.

        Args:
            path (PathLike):
                Path to file.
        """
        self.path = Path(path)

    def __getitem__(self, index: Tuple[Union[int, slice], ...]) -> np.ndarray:
        """Get pixel data at index."""
        raise NotImplementedError

    @classmethod
    def from_file(cls, path: Path) -> "Reader":
        """Return reader for file.

        Args:
            path (Path): Path to file.

        Returns:
            Reader: Reader for file.
        """
        path = Path(path)
        if path.is_dir() and path.suffix == ".zarr":
            from wsic.writers import ZarrReaderWriter

            return ZarrReaderWriter(path, overwrite=True)
        file_types = summon_file_types(path)
        if ("jp2",) in file_types:
            return JP2Reader(path)
        if ("tiff", "svs") in file_types:
            return OpenSlideReader(path)
        if ("tiff",) in file_types:
            return TIFFReader(path)
        raise ValueError(f"Unsupported file type: {path}")


def get_tile(
    queue: multiprocessing.Queue,
    ji: Tuple[int, int],
    tilesize: Tuple[int, int],
    path: Path,
) -> np.ndarray:
    """Append a tile read from a reader to a multiprocessing queue.

    Args:
        queue (multiprocessing.Queue):
            Queue to put tiles on to.
        ji (Tuple[int, int]):
            Index of tile.
        tilesize (Tuple[int, int]):
            Tile size as (width, height).
        path (Path):
            Path to file to read from.

    Returns:
        Tuple[Tuple[int, int], np.ndarray]:
            Tuple of the tile index and the tile.
    """
    reader = Reader.from_file(path)
    # Read the tile
    j, i = ji
    index = (
        slice(j * tilesize[1], (j + 1) * tilesize[1]),
        slice(i * tilesize[0], (i + 1) * tilesize[0]),
    )
    # Filter warnings (e.g. from gylmur about reading past the edge)
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        tile = reader[index]
    queue.put((ji, tile))


class MultiProcessTileIterator:
    """An iterator which returns tiles generated by a reader.

    This is a fancy iterator that uses a multiprocress queue to
    accelerate the reading of tiles. It can also use an intermediate
    file to allow for reading and writing with different tile sizes.

    Args:
        reader (Reader):
            Reader for image.
        read_tile_size (Tuple[int, int]):
            Tile size to read from reader.
        yield_tile_size (Optional[Tuple[int, int]]):
            Tile size to yield. If None, yield_tile_size = read_tile_size.
        num_workers (int):
            Number of workers to use.
        intermediate (Path):
            Intermediate reader/writer to use. Must support random
            access reads and writes.
        verbose (bool):
            Verbose output.

    Yields:
        np.ndarray:
            A tile from the reader.
    """

    def __init__(
        self,
        reader: Reader,
        read_tile_size: Tuple[int, int],
        yield_tile_size: Optional[Tuple[int, int]] = None,
        num_workers: int = None,
        intermediate=None,
        verbose: bool = False,
    ) -> None:
        self.reader = reader
        self.shape = reader.shape
        self.read_tile_size = read_tile_size
        self.yield_tile_size = yield_tile_size or read_tile_size
        self.intermediate = intermediate
        self.verbose = verbose
        self.queue = multiprocessing.Queue()
        self.enqueued = set()
        self.reordering_dict = {}
        self.read_j = 0
        self.read_i = 0
        self.yield_i = 0
        self.yield_j = 0
        self.num_workers = num_workers or os.cpu_count() or 2
        self.read_mosaic_shape = mosaic_shape(
            self.shape,
            self.read_tile_size[::-1],
        )
        self.yield_mosaic_shape = mosaic_shape(
            self.shape,
            self.yield_tile_size[::-1],
        )
        self.remaining_reads = list(np.ndindex(self.read_mosaic_shape))
        self.tile_status = zarr.zeros(self.yield_mosaic_shape, dtype="u1")
        try:
            from tqdm.auto import tqdm

            self.read_pbar = tqdm(
                total=np.prod(self.read_mosaic_shape),
                desc="Reading",
                colour="cyan",
                smoothing=0.01,
            )
        except ImportError:
            self.read_pbar = None

        # Validation and error handling
        if self.read_tile_size != self.yield_tile_size and not self.intermediate:
            raise ValueError(
                f"read_tile_size ({self.read_tile_size})"
                f" != yield_tile_size ({self.yield_tile_size})"
                " and intermediate is not set. An intermediate is"
                " required when the read and yield tile size differ."
            )

    def __len__(self) -> int:
        """Return the number of tiles in the reader."""
        return int(np.prod(self.yield_mosaic_shape))

    def __iter__(self) -> Iterator:
        """Return an iterator for the reader."""
        self.read_j = 0
        self.read_i = 0
        return self

    @property
    def read_index(self) -> Tuple[int, int]:
        """Return the current read index."""
        return self.read_j, self.read_i

    @read_index.setter
    def read_index(self, value: Tuple[int, int]) -> None:
        """Set the current read index."""
        self.read_j, self.read_i = value

    @property
    def yield_index(self) -> Tuple[int, int]:
        """Return the current yield index."""
        return self.yield_j, self.yield_i

    @yield_index.setter
    def yield_index(self, value: Tuple[int, int]) -> None:
        """Set the current yield index."""
        self.yield_j, self.yield_i = value

    def wrap_indexes(self) -> None:
        """Wrap the read and yield indexes."""
        self.read_index, overflow = wrap_index(self.read_index, self.read_mosaic_shape)
        if overflow and self.verbose:
            print("All tiles read.")
        self.yield_index, overflow = wrap_index(
            self.yield_index, self.yield_mosaic_shape
        )
        if overflow and self.verbose:
            print("All tiles yielded.")
        elif overflow:
            self.read_pbar.close()
            raise StopIteration

    def __next__(self) -> np.ndarray:
        """Return the next tile from the reader."""
        # Ensure a valid read ij index
        self.wrap_indexes()

        # Add tile reads to the queue until the maximum number of
        # workers is reached
        self.fill_queue()

        # Get the next yield tile from the queue
        for _ in range(100):
            # Remove all tiles from the queue into the reordering dict
            self.empty_queue()

            # Remove the next read tile from the reordering dict. May be
            # None if the read tile is not in the reordering dict or if
            # an intermediate is used.
            tile = self.pop_next_read_tile()

            # Return the tile if no intermediate is being used and the
            # tile was in the reordering dict.
            if not self.intermediate and tile is not None:
                return tile

            # Get the next tile from the intermediate. Returns None if
            # intermediate is None or the tile is not in the
            # intermediate.
            tile = self.read_next_from_intermediate()
            if tile is not None:
                return tile

            # Ensure the queue is kept full
            self.fill_queue()

            # Sleep and try again
            time.sleep(0.1)
        warnings.warn(
            "Failed to get next tile after 100 attempts. Dumping debug information."
        )
        print(f"Reader Shape {self.reader.shape}")
        print(f"Read Tile Size {self.read_tile_size}")
        print(f"Yield Tile Size {self.yield_tile_size}")
        print(f"Read Mosaic Shape {self.read_mosaic_shape}")
        print(f"Yield Mosaic Shape {self.yield_mosaic_shape}")
        print(f"Read Index {self.read_index}")
        print(f"Yield Index {self.yield_index}")
        print(f"Remaining Reads (:10) {self.remaining_reads[:10]}")
        print(f"Enqueued (:10) {self.enqueued[:10]}")
        print(f"Reordering Dict (keys) {self.reordering_dict.keys()}")
        print(f"Queue Size {self.queue.qsize()}")
        intermediate_read_slices = tile_slices(
            index=(self.yield_j, self.yield_i),
            shape=self.yield_tile_size[::-1],
        )
        print(f"Intermediate Read slices {intermediate_read_slices}")
        raise Exception(f"Failed to yield tile {self.yield_index}")

    def read_next_from_intermediate(self) -> Optional[np.ndarray]:
        """Read the next tile from the intermediate file."""
        if self.intermediate is None:
            return None
        intermediate_read_slices = tile_slices(
            index=(self.yield_j, self.yield_i),
            shape=self.yield_tile_size[::-1],
        )
        status = self.tile_status[self.yield_index]
        if np.all(status == 1):  # Intermediate has all data for the tile
            self.tile_status[self.yield_index] = 2
            self.yield_i += 1
            return self.intermediate[intermediate_read_slices]
        return None

    def empty_queue(self) -> None:
        """Remove all tiles from the queue into the reordering dict."""
        while not self.queue.empty():
            ji, tile = self.queue.get()
            self.reordering_dict[ji] = tile

    def fill_queue(self) -> None:
        """Add tile reads to the queue until the max number of workers is reached."""
        while len(self.enqueued) < self.num_workers and len(self.remaining_reads) > 0:
            next_ji = self.remaining_reads.pop(0)
            proc = multiprocessing.Process(
                target=get_tile,
                args=(
                    self.queue,
                    next_ji,
                    self.read_tile_size,
                    self.reader.path,
                ),
            )
            proc.start()
            self.enqueued.add(next_ji)

    def update_read_pbar(self) -> None:
        """Update the read progress bar."""
        if self.read_pbar is not None:
            self.read_pbar.update()

    def pop_next_read_tile(self) -> Optional[np.ndarray]:
        """Remove the next tile from the reordering dict.

        Returns:
            Optional[np.ndarray]:
                The next tile from the reordering dict if available.
                If an intermediate is being used, or the tile is not
                in the reordering dict, this will be None.
        """
        read_ji = (self.read_j, self.read_i)
        if read_ji in self.reordering_dict:
            self.enqueued.remove(read_ji)
            tile = self.reordering_dict.pop(read_ji)

            # If no intermediate is required, return the tile
            if not self.intermediate:
                if tile is None:
                    raise Exception(f"Tile {read_ji} is None")
                self.read_i += 1
                self.update_read_pbar()
                self.yield_i += 1
                return tile

            # Otherwise, write the tile to the intermediate
            intermediate_write_index = tile_slices(
                index=read_ji,
                shape=self.read_tile_size,
            )
            self.intermediate[intermediate_write_index] = tile
            tile_status_index = tuple(
                slice(max(0, floor(x.start / r)), ceil(x.stop / r))
                for x, r in zip(intermediate_write_index, self.yield_tile_size)
            )
            self.tile_status[tile_status_index] = 1
            self.read_i += 1
            self.update_read_pbar()
        return None


class JP2Reader(Reader):
    """Reader for JP2 files using glymur.

    Args:
        path (Path): Path to file.
    """

    def __init__(self, path: Path) -> None:
        super().__init__(path)
        import glymur

        # Enable multithreading
        if glymur.options.version.openjpeg_version_tuple >= (2, 2, 0):
            glymur.set_option("lib.num_threads", multiprocessing.cpu_count())

        self.jp2 = glymur.Jp2k(str(path))
        self.shape = self.jp2.shape
        self.dtype = np.uint8
        self.axes = "YXS"
        self.microns_per_pixel = self._get_mpp()
        self.tile_shape = self._get_tile_shape()

    def _get_mpp(self) -> Optional[Tuple[float, float]]:
        """Get the microns per pixel for the image.

        Returns:
            Optional[Tuple[float, float]]:
                The resolution of the image in microns per pixel.
                If the resolution is not available, this will be None.
        """
        import glymur

        boxes = {type(box): box for box in self.jp2.box}
        header_box = boxes[glymur.jp2box.JP2HeaderBox]
        header_sub_boxes = {type(box): box for box in header_box.box}
        resolution_box = header_sub_boxes.get(glymur.jp2box.ResolutionBox)
        if resolution_box is None:
            return None
        resolution_sub_boxes = {type(box): box for box in resolution_box.box}
        capture_resolution_box = resolution_sub_boxes.get(
            glymur.jp2box.CaptureResolutionBox
        )
        if capture_resolution_box is None:
            return None
        y_res = capture_resolution_box.vertical_resolution
        x_res = capture_resolution_box.horizontal_resolution
        return ppu2mpp(x_res, "cm"), ppu2mpp(y_res, "cm")

    def _get_tile_shape(self) -> Tuple[int, int]:
        """Get the tile shape as a (height, width) tuple.

        Returns:
            Tuple[int, int]:
                The tile shape as (height, width).
        """
        import glymur

        boxes = {type(box): box for box in self.jp2.box}
        ccb = boxes.get(glymur.jp2box.ContiguousCodestreamBox, None)
        if ccb is None:
            raise ValueError("No codestream box found.")
        segments = {type(segment): segment for segment in ccb.codestream.segment}
        siz = segments.get(glymur.codestream.SIZsegment, None)
        if siz is None:
            raise ValueError("No SIZ segment found.")
        return (siz.ytsiz, siz.xtsiz)

    def __getitem__(self, index: tuple) -> np.ndarray:
        """Get pixel data at index."""
        return self.jp2[index]


class TIFFReader(Reader):
    """Reader for TIFF files using tifffile."""

    def __init__(self, path: Path) -> None:
        """Initialize reader.

        Args:
            path (Path): Path to file.
        """
        import tifffile

        super().__init__(path)
        self.tiff = tifffile.TiffFile(str(path))
        self.tiff_page = self.tiff.pages[0]
        self.array = self.tiff_page.asarray()
        self.shape = self.array.shape
        self.dtype = self.array.dtype
        self.axes = self.tiff.series[0].axes
        self.is_tiled = self.tiff_page.is_tiled
        self.tile_shape = None
        self.mosaic_shape = None
        self.mosaic_byte_offsets = None
        self.mosaic_byte_counts = None
        if self.is_tiled:
            self.tile_shape = (self.tiff_page.tilelength, self.tiff_page.tilewidth)
            self.mosaic_shape = mosaic_shape(
                array_shape=self.shape, tile_shape=self.tile_shape
            )
            self.mosaic_byte_offsets = np.array(self.tiff_page.dataoffsets).reshape(
                self.mosaic_shape
            )
            self.mosaic_byte_counts = np.array(self.tiff_page.databytecounts).reshape(
                self.mosaic_shape
            )
        self.jpeg_tables = self.tiff_page.jpegtables
        self.colour_space = normalise_color_space(self.tiff_page.photometric)
        self.compression = normalise_compression(self.tiff_page.compression)

    def get_tile(self, index: Tuple[int, int], decode: bool = True) -> np.ndarray:
        """Get tile at index.

        Args:
            index (Tuple[int, int]):
                The index of the tile to get.
            decode (bool, optional):
                Whether to decode the tile. Defaults to True.

        Returns:
            np.ndarray:
                The tile at index.
        """
        flat_index = index[0] * self.tile_shape[1] + index[1]
        fh = self.tiff.filehandle
        _ = fh.seek(self.mosaic_byte_offsets[index])
        data = fh.read(self.mosaic_byte_counts[index])
        if not decode:
            return data
        tile, _, _ = self.tiff_page.decode(
            data, flat_index, jpegtables=self.tiff_page.jpegtables
        )
        return tile

    def __getitem__(self, index: Tuple[Union[slice, int]]) -> np.ndarray:
        """Get pixel data at index."""
        return self.array[index]


class OpenSlideReader(Reader):
    """Reader for OpenSlide files using openslide-python."""

    def __init__(self, path: Path) -> None:
        import openslide

        super().__init__(path)
        self.os_slide = openslide.OpenSlide(str(path))
        self.shape = self.os_slide.level_dimensions[0][::-1] + (3,)
        self.dtype = np.uint8
        self.axes = "YXS"
        self.tile_shape = None  # No easy way to get tile shape currently
        self.microns_per_pixel = self._get_mpp()

    def _get_mpp(self) -> Optional[Tuple[float, float]]:
        """Get the microns per pixel for the image.

        Returns:
            Optional[Tuple[float, float]]:
                The microns per pixel as (x, y) tuple.
        """
        try:
            return (
                self.os_slide.properties["openslide.mpp-x"],
                self.os_slide.properties["openslide.mpp-y"],
            )
        except KeyError:
            warnings.warn("OpenSlide could not find MPP.")
        # Fall back to TIFF resolution tags
        try:
            resolution = (
                self.os_slide.properties["tiff.XResolution"],
                self.os_slide.properties["tiff.YResolution"],
            )
            units = self.os_slide.properties["tiff.ResolutionUnit"]
            self._check_sensible_resolution(resolution, units)
            return tuple(ppu2mpp(x, units) for x in resolution)
        except KeyError:
            warnings.warn("No resolution metadata found.")
        return None

    @staticmethod
    def _check_sensible_resolution(
        tiff_resolution: Tuple[float, float], tiff_units: int
    ) -> None:
        """Check whether the resolution is sensible.

        It is common for TIFF files to have incorrect resolution tags.
        This method checks whether the resolution is sensible and warns
        if it is not.

        Args:
            tiff_resolution (Tuple[float, float]):
                The TIFF resolution as an (x, y) tuple.
            tiff_units (int):
                The TIFF units of the resolution. A value of 2 indicates
                inches and a value of 3 indicates centimeters.
        """
        if tiff_units == 2 and 72 in tiff_resolution:
            warnings.warn(
                "TIFF resolution tags found."
                " However, they have a common default value of 72 pixels per inch."
                " This may from a misconfigured software library or tool"
                " which is expecting to handle print documents."
            )
        if 0 in tiff_resolution:
            warnings.warn(
                "TIFF resolution tags found."
                " However, one or more of the values is zero."
            )

    def __getitem__(self, index: Tuple[Union[int, slice], ...]) -> np.ndarray:
        """Get pixel data at index."""
        xs: slice = index[1]
        ys: slice = index[0]
        start_x = xs.start or 0
        start_y = ys.start or 0
        end_x = xs.stop or self.shape[1]
        end_y = ys.stop or self.shape[0]

        # Prevent reading past the edges of the image
        end_x = min(end_x, self.shape[1])
        end_y = min(end_y, self.shape[0])

        # Read the image
        img = self.os_slide.read_region(
            location=(start_x, start_y),
            level=0,
            size=(end_x - start_x, end_y - start_y),
        )
        return np.array(img.convert("RGB"))
